---
id: "566843955233165312"
author: "Astor"
title: "AWS ECS 인프라 구축 가이드라인"
pinned: false
draft: false
tags:
  - AWS
  - ECS
  - Fargate
ogImage: "https://d2r0pavv0lsiqc.cloudfront.net/posts/images/29ab6e9b-e2f3-4204-b24b-1be63033d6b6.webp"
seriesId: "556500951268069379"
description: "ECS 배포 방식을 소개합니다."
createdAt: "2025-04-11 14:23:31"
updatedAt: "2025-04-14 14:21:39"
---

## 시작하며: 문제 및 필요성

초기 서비스 단계에서는 관리의 직관성과 환경의 단순성을 이유로 EC2와 같은 가상 머신(VM) 기반의 인프라를 선택하는 경우가 많습니다. 이는 빠른 배포와 소규모 운영에는 일정 수준의 유효성을 지니지만, 점차 서비스 트래픽이 증가하고 배포 주기가 짧아질수록 인프라 운영의 비효율성과 확장성의 한계가 드러납니다.

가장 큰 제약 중 하나는 **수평 확장의 어려움**입니다. VM 기반 서버는 물리적 또는 논리적 자원을 기준으로 스케일링해야 하며, 신규 인스턴스를 프로비저닝하는 데 시간이 소요되고, 설정과 이미지 관리도 번거롭습니다. **무중단 배포** 또한 복잡한 로직과 헬스체크 전략을 요구하며, 배포 실패 시 롤백 관리가 어렵습니다. 이로 인해 운영 리스크가 누적되며, 배포 자동화 파이프라인의 안정성 확보 또한 어렵습니다.

이러한 한계를 해결하기 위해 컨테이너 기반의 오케스트레이션 환경이 필요하며, Amazon ECS는 그 대안으로써 명확한 이점을 제공합니다. 특히 **AWS Fargate 기반의 ECS**는 인프라 자원 관리 없이 컨테이너 단위로 애플리케이션을 정의하고 실행할 수 있게 해 주며, Auto Scaling 및 롤링 배포가 기본적으로 내장되어 있습니다. 결과적으로 ECS는 **서비스의 민첩성과 확장성을 동시에 확보**할 수 있게 해주는 현실적인 대안이자, MSA 아키텍처로의 전환에도 적합한 기반 인프라로 작용합니다.

![](https://d2r0pavv0lsiqc.cloudfront.net/projects/images/f75739c4-aa72-486a-b8de-b7a5143914ed.webp)

저희가 최종적으로 구축할 인프라는 위와 같은 형태가 될 예정입니다.

### 전제 조건

이 글의 범위는 **클라우드 인프라 구성**에 한정되며, 애플리케이션 레벨에서 발생할 수 있는 문제(예: 동시성 이슈, 리더 선출, graceful shutdown 등)는 이미 해결되었다고 가정합니다. 다시 말해, 이 포스팅에서는 **ECS 기반 배포 환경 구성**에만 집중합니다.

또한 VPC 설정은 별도 심화 주제로 다루지 않으며, 본 글에서는 **기본적으로 Public Subnet만 사용하는 구조**를 전제로 합니다.
Private Subnet을 활용하고자 하는 경우, 예를 들어 Secrets Manager 등 외부 서비스와의 통신이 필요한 환경에서는 NAT Gateway 설정이 필수적이며, 이 경우 비용 및 복잡도가 증가합니다. 따라서 이러한 아키텍처를 설계를 원하실 경우, 본 포스팅 이외로도 조사를 철저히 하시길 권합니다.

**ACM 및 도메인 인증서에 대해서도 다루지 않습니다.** 사전에 도메인을 구매, ACM에 등록해두시기 바랍니다.

### ECS 런타임 - Fargate vs EC2

![AWS Fargate 출시 – 서버리스 콘테이너 서비스 | Amazon Web Services 한국 블로그](https://d2908q01vomqb2.cloudfront.net/da4b9237bacccdf19c0760cab7aec4a8359010b0/2017/11/29/Picture1.png)

ECS는 EC2 기반과 Fargate 기반이라는 두 가지 런타임 모드를 제공합니다. 본 포스팅에서는 **Fargate 기반 ECS**를 전제로 하며, 이는 단순히 인프라 관리의 편의성 때문만이 아니라, **자원 회수 구조의 근본적인 효율성 차이** 때문입니다.

EC2 기반 ECS는 무중단 배포(Rolling Update)를 위해 신규 버전의 태스크를 실행할 때, 기존 태스크와의 공존을 위해 **일시적으로 더 많은 리소스를 필요로 합니다**. 이 과정에서 다음과 같은 문제가 발생합니다:

- 새로운 태스크를 수용할 수 있는 여유 자원이 부족할 경우, ECS는 오토스케일링 그룹을 통해

  **추가 EC2 인스턴스를 생성**

  합니다.
- 배포가 완료되고 기존 태스크가 중지되더라도,

  **인스턴스 레벨의 리소스는 즉시 회수되지 않습니다.**
- 이는 특히

  **태스크 단위 리소스 요구량이 작고, 배포 주기가 짧은 서비스**

  일수록 인스턴스가

  **부분적으로만 활용된 채 계속 유지**

  되며

  **자원 낭비**

  로 이어집니다.

예를 들어, 한 EC2 인스턴스가 4개의 태스크를 수용할 수 있는데, 배포 과정에서 잠시 2개 태스크가 더 필요해 인스턴스가 하나 추가되었다면, 이후 기존 태스크가 종료되더라도 그 **신규 인스턴스는 일부 리소스만 사용된 채 계속 떠 있는** 구조가 됩니다. ECS는 인스턴스가 부분적으로 비워져도 이를 자동으로 정리하지 않기 때문에, **리소스 릴리즈가 비효율적으로 작동합니다**.

반면 Fargate는 **태스크 단위로 리소스를 생성하고, 종료 시 해당 자원을 완전히 릴리즈**합니다. 인프라 수준의 리소스를 사용자 측에서 직접 관리하지 않기 때문에,

- 배포 중 리소스가 잠시 증가하더라도,
- 배포 완료 후에는

  **불필요한 자원이 자동으로 제거**

  됩니다.

이는 자원이 **부분적으로 유휴 상태로 남아있는 상황을 방지**하고, 실제 사용한 만큼만 과금되도록 함으로써, 운영 비용 최적화에 있어 구조적으로 유리합니다.

## 대상그룹 & 로드 밸런서 세팅하기

먼저 ECS를 생성하기 전에 로드 밸런서를 생성하겠습니다.

ECS 생성 페이지에서 로드 밸런서를 만드는 방식도 있지만, 해당 방식으로 만든 경우 **서비스 삭제 시 로드 밸런서가 삭제**된다던가, 정밀한 제어를 못한다던가 여러 면에서 조금 귀찮아지기 때문에 먼저 필요한 인프라들을 만들어놓고 가겠습니다.

### 대상 그룹 생성

![](https://d2r0pavv0lsiqc.cloudfront.net/projects/images/9f6843c2-2cac-43b3-8502-f4770b7d672d.webp)

EC2 >대상 그룹에서 IP 주소를 대상 그룹으로 하여 대상그룹을 만들어줍니다.

![](https://d2r0pavv0lsiqc.cloudfront.net/projects/images/caff75a2-a29d-4d18-b22d-c75f27be6531.webp)

세팅에서 주의하실 점은 대상 그룹의 **포트설정**입니다. 추후 ECS에서 실행할 서버에 대한 정의(task-definition)을 설정할텐데, Fargate 기반의 서비스는 `컨테이너의 실행 포트와 호스트의 포트가 같아야`합니다. 즉 서버를 3000번 포트로 띄운다고 하면, 기존 도커에서 하던 것 처럼 443:3000 처럼 포트 매핑하는게 불가능합니다. 대상그룹 생성 시 부터, **서버가 리스닝하고 있는 포트**와 맞추어서 생성해줍시다.

![](https://d2r0pavv0lsiqc.cloudfront.net/projects/images/e4d3b4bd-107d-4e9b-b018-71986c23e13f.webp)

나머지는 쭉 만들되, 헬스체크는 서버 측에서 엔드포인트 하나를 설정해주시기 바랍니다.

![](https://d2r0pavv0lsiqc.cloudfront.net/projects/images/3c179c23-3cc1-47e9-a81b-d2ef145655eb.webp)

고급 상태 검사 설정 쪽을 보시면 성공 코드가 명시되어있습니다. 여기서 만약 아무 설정 없이 대상그룹을 만든다면 기본값이 `/`(루트), `200`이 될텐데 보통 서버앱의 root path는 사용하지 않으실테니 404가 뜰 겁니다. 정상적으로 서버가 부팅되어도 실패하죠. 따라서 서버 부팅을 확인할 수 있고, 200 응답을 주는 엔드포인트 하나를 개설한 뒤에 대상 그룹에 연결해주세요.

![](https://d2r0pavv0lsiqc.cloudfront.net/projects/images/f84b5328-3d42-4092-ac4b-0724f95a82ff.webp)

IP 지정 및 포트 정의는 빈 값으로 둡니다.

![](https://d2r0pavv0lsiqc.cloudfront.net/projects/images/f222a51f-0a5a-4697-adbb-5d674046bd0d.webp)

생성이 완료되셨으면 대상 그룹의 속성 탭으로 가서 등룩 취소 지연을 줄여줍니다.

CICD 때 시간을 잡아먹는 주범입니다. 이 지연 시간이 끝나야 기존 인스턴스가 내려가는데, 수십초 이상의 연산이 필요한 작업을 수행하는 게 아닌 이상 60초 아래로 설정하셔도 좋습니다. 보통 graceful shutdown과 트랜잭션을 잘 구현해두셨다면 지연이 필요 없는 경우가 많습니다.

### 로드 밸런서 생성

![](https://d2r0pavv0lsiqc.cloudfront.net/projects/images/02d60b6b-c5a0-4b0a-b1fb-b3a2624cfe82.webp)

이제 로드밸런서를 생성해줍니다. HTTPS를 활용할테니 Application Load Balancer를 설정합니다.

![](https://d2r0pavv0lsiqc.cloudfront.net/projects/images/da4ca24c-2cec-4d56-bbb9-94bbc7133742.webp)

이름이나 서브넷 쭉 설정해주시고 리스너 및 라우팅에서 아까 만든 대상그룹을 지정해줍니다.

![](https://d2r0pavv0lsiqc.cloudfront.net/projects/images/3e9a05b8-2161-4ec2-9397-8e8eff77dd35.webp)

ACM에서 만들어둔 인증서 가져와줍니다. 안 만들어두신 분들은 잠깐 구글링 하셔서 만드시고 오세요! 이 글에선 범위가 넓어져 다루지 않습니다.&#x20;

![](https://d2r0pavv0lsiqc.cloudfront.net/projects/images/c687df7a-7bb5-43a5-ac53-f5cb4e1fa030.webp)

보안그룹은 80(선택), 443열어두시고, elb임을 식별할 수 있는 고유한 보안그룹도 하나 할당해주세요. 추후 ecs에서 로드 밸런서 한정으로 포트를 열 때 사용합니다.

80포트 열어두실거면 아래의 리스너 설정을 추가로 해주세요.

우선 이대로 생성을 해줍니다.

### (선택)로드 밸런서: 리스너 설정

생성이 완료 되셨으면 이제 리스너들 설정을 좀 더 해줍니&#xB2E4;**. dev서버와 prod서버를 하나의 alb로 처리**하고 싶으신 분, **http로 접속 시 https로 리디렉션** 시키고 싶으신 분은 이 단락을 따라와주세요.

#### 호스트 헤더로 조건 분기하기

![](https://d2r0pavv0lsiqc.cloudfront.net/projects/images/982ed9ef-6dbd-4c5f-a09b-63b4f3ba184f.webp)

아까만든 HTTPS:443 리스너에 들어가서 리스너 규칙을 추가해줍니다.

![](https://d2r0pavv0lsiqc.cloudfront.net/projects/images/857f449e-a7d2-458b-9873-521018ae388a.webp)

원하시는 서브도메인을 호스트헤더로 하여 조건을 추가해줍니다.

## IAM 세팅하기

## ECR 세팅하기&#x20;

###

## ECS 세팅하기

### Task Definition 생성하기

## CD: github action -> ecr -> ecs

###

## E

## 마무리하며: 보완할 포인트들