---
id: "617976368214315008"
author: "Astor"
title: "WAS에서 Kafka 다루기: ACKS 옵션과 ISR, 메시지 전송 신뢰도"
pinned: true
draft: true
tags:
  - Kafka
ogImage: "https://d2r0pavv0lsiqc.cloudfront.net/posts/images/7b52434b-7b32-44e7-a459-eada436d74ba.webp"
seriesId: "560288274048880643"
createdAt: "2025-09-02 15:04:20"
updatedAt: "2025-09-02 15:57:27"
---

지난 글에서는 프로듀서, 컨슈머, 브로커, 토픽, 파티션 등 카프카의 핵심 개념과 아키텍처에 대해 알아보았습니다. 프로듀서가 `producer.send()`를 통해 메시지를 발행하면, 해당 메시지는 토픽의 파티션으로 전송되고 컨슈머가 이를 가져가 처리하는 흐름을 이해했습니다.

그런데 여기서 한 가지 중요한 질문이 생깁니다. `producer.send()`를 호출하고 나면, 우리는 **"메시지가 안전하게 전송되었다"라고 언제 확신할 수 있을까요?** 프로듀서의 요청이 리더 브로커에 도달하자마자일까요? 아니면 모든 복제본에 저장이 완료되었을 때일까요?

바로 이 신뢰도의 수준을 애플리케이션의 요구사항에 맞게 정밀하게 제어하는 핵심 장치가 바로 **프로듀서의** `acks` **옵션**입니다. 이번 글에서는 acks 옵션과 이를 뒷받침하는 **ISR(In-Sync Replicas)** 개념을 통해 카프카가 어떻게 메시지 전송의 신뢰도를 보장하는지, 그리고 개발자로서 우리는 어떤 트레이드오프를 고려해야 하는지 알아보겠습니다.

## **acks 옵션**

![](https://d2r0pavv0lsiqc.cloudfront.net/projects/images/a57c2988-2f2c-47f9-aac5-81a4015ecbc7.webp)

acks는 **"acknowledgments"**&#xC758; 약자로, 프로듀서가 보낸 메시지에 대해 브로커로부터 **"잘 받았다"는 확인 응답을 얼마나 기다릴지** 결정하는 설정 값입니다. **프로듀서 측에서 설정**해주어야 합니다.

이 옵션은 크게 세 가지로 나뉩니다.

[(이미지 및 정보 출처 - confluent)](https://developer.confluent.io/courses/architecture/guarantees/)

### **acks=0: Fire-and-Forget**

![producer-acks-0](https://images.ctfassets.net/gt6dp23g0g38/6pfzwjpx5YWvwFENsCLMC4/b82981d84c69f595d7a0c444a3b0113a/Kafka_Internals_088.png)

> lower latency / no strong durability&#x20;

프로듀서는 메시지를 브로커로 전송하고, **어떠한 확인 응답도 기다리지 않습니다. (fire and forget)** 그냥 네트워크 버퍼에 메시지를 쓰는 순간 "전송 성공"으로 간주합니다.

**낮은 지연시간으로 인해 높은 처리량**을 보장하지만, **메시지 유실 위험이 매우 높습**니다.

일부가 유실되어도 전체 시스템에 큰 영향이 없는 데이터 수집 (로그, 메트릭 수집 등)에 적합합니다.

- **데이터 유실:** 브로커가 메시지를 받기 전에 프로듀서에 장애가 발생하거나, 네트워크 문제, 브로커가 다운되는 경우&#x20;
- **메시지 중복:** <u>발생 X</u>

### **acks=1 리더 브로커의 확인만 받는다**

![producer-acks-1](https://images.ctfassets.net/gt6dp23g0g38/3p6EMq0jqOYJbabjyCPqWO/c5e82fd9772f82fc2ad4e75f7edc1889/Kafka_Internals_089.png)

> a little higher latency  / a little bit better durability&#x20;

프로듀서는 메시지를 보낸 후, **파티션의 리더 브로커가 자신의 로컬 디스크에 메시지를 기록했다는 확인 응답**을 받을 때까지 기다립니다.

보통의 카프카 인프라에선 레플리카 옵션으로 리더 브로커의 데이터를 팔로워에서 주기적으로 복제해 리더 인스턴스의 장애에 대응합니다. 이 옵션은 프로듀서가 리더 브로커한테만 메시지 확인 유무에 대한 응답을 기다립니다. 만약 설정한 시간동안 응답이 오지 않으면, **메시지를 재발행**합니다.

리더 브로커에 확인을 받는 만큼, **지연시간이 조금 더** 생기지만, 그만큼 **유실 위험성을 낮출** 수 있습니다.

- **데이터 유실**: 리더 파티션이 메시지를 받은 후 응답을 보냈으나, 팔로워 파티션들이 복제하기 전에 리더가 다운
- **메시지 중복**: 프로듀서가 리더로부터 응답을 받지 못해 메시지를 재전송할 경우
  - ex) 리더가 메시지를 받았지만 ack 응답을 보내기 전에 장애가 나, 프로듀서가 메시지가 전송되지 않았다고 판단하고 재시도한 경우

### **acks=all (OR -1): 모든 복제본의 확인을 받는다**

![producer-acks-all](https://images.ctfassets.net/gt6dp23g0g38/2PE3eY4NoxDiz5zBCrideK/413838ed6666f45f89ee396d714dda49/Kafka_Internals_090.png)

>  higher latency / highest level of durability&#x20;

프로듀서는 **리더 브로커뿐만 아니라, 해당 파티션을 복제하고 있는 모든 'In-Sync' 상태의 팔로워 브로커들(ISR)까지 메시지를 기록했다는 확인 응답**을 모두 받을 때까지 기다립니다.&#x20;

ISR(In-Sync Replicas)은 **리더 파티션을 포함하여** 거의 실시간으로 리더의 모든 메시지를 복제하고 있는 레플리카들의 집합입니다.

리더와 팔로워들의 응답을 모두 기다려야 하기 때문에, **지연시간이 가장 깁**니다.&#x20;

- **데이터 유실**:  `min.insync.replicas` 설정보다 적은 수의 레플리카가 동기화되어 있을 때, 프로듀서의 요청이 실패하는 경우 혹은 모든 레플리카가 동시에 다운되는 경우
- **메시지 중복**: 모든 ISR에 복제가 완료되었지만, 리더 브로커의 최종 응답을 받지 못하고 프로듀서가 재시도하는 경우

#### 프로듀서 멱등성(Idempotence)

![producer-idempotency](https://images.ctfassets.net/gt6dp23g0g38/5NH8JBhOQWlZNiki8Ff5iE/b50426ae88cc1bdcfe12f1e9e5878c19/Kafka_Internals_092.png)

프로듀서 멱등성은 동일한 메시지를 여러 번 전송해도 카프카 브로커에 **정확히 한 번만 기록되도록** 보장하는 기능입니다. 이 기능은 `acks=-1` 설정과 결합되어 프로듀서의 재시도로 인한 메시지 중복 문제를 해결합니다.

**설정 시 acks=-1을 강제**하며, `enable.idempotence=true` 를 통해 설정합니다.

멱등성이 true로 설정된 프로듀서는 고유한 ID를 할당 받고 **각 메시지에 자신의 ID와 Sequence Number를 부여해 브로커에게 전송**합니다.

브로커는 **각 프로듀서가 파티션에 마지막으로 기록한 메시지의 Sequence Number**를 기억합니다. 프로듀서가 메시지를 재전송하면, 브로커는 메시지에 포함된 Sequence Number를 확인하여 이전에 이미 받은 메시지인지 판단합니다.

만약 수신된 메시지의 Sequence Number가 이미 기록된 Sequence Number와 같거나 더 작으면, 브로커는 해당 메시지를 중복으로 간주하고 무시합니다.

이를 통해 **단일 세션** 내에서의 메시지 중복 문제를 해결할 수 있습니다.

#### 한계

멱등성(Idempotence)은 **단일 프로듀서 세션** 내에서만 작동합니다.

하지만 프로듀서 프로세스가 **충돌하거나 재시작**되면, 기존에 처리중이던 메시지도 유실될 수 있고, redis 등으로 재시도 로직을 엔지니어링 해도 새로운 인스턴스는 **브로커로부터 완전히 새로운 고유 ID**를 할당받기에 중복 발송을 해결할 수 없습니다.&#x20;

이러한 문제를 해결하기 위해 카프카의 **트랜잭션(Transactions)** 기능이 필요합니다. 이는 추후 알아보겠습니다.

### **ISR (In-Sync Replicas)**

acks 설정과 연관있는 ISR에 대해 좀 더 자세히 알아보겠습니다.

카프카 클러스터는 안정성을 위해 각 파티션의 데이터를 여러 브로커에 복제해 둡니다. 이때, **리더의 최신 데이터와 거의 차이가 없이 동기화가 잘 유지되고 있는 팔로워 복제본들의 집합**을 `ISR`이라고 부릅니다.

만약 어떤 팔로워가 네트워크 문제나 과도한 부하로 인해 리더의 데이터를 제때 복제하지 못하고 뒤처지게 되면, 카프카는 이 팔로워를 '동기화되지 않은(out-of-sync)' 것으로 판단하고 ISR 그룹에서 **임시로 제외**시킵니다.

#### **최소 복제본 개수: `min.insync.replicas`**

`acks=all`을 사용할 때 반드시 함께 고려해야 할 브로커 설정이 바로 `min.insync.replicas` 입니다. 이 설정은 프로듀서의 쓰기 요청을 처리하기 위해 **반드시 필요한 최소 ISR의 개수**를 지정합니다.

예를 들어, 토픽의 복제 계수(Replication Factor)가 3이고 `min.insync.replicas`를 2로 설정했다고 가정해 봅시다.

- **정상 상황:** 리더 1대, 팔로워 2대. 총 3개의 복제본이 모두 ISR에 속해 있습니다. `acks=all` 요청은 3대의 브로커가 모두 확인 응답을 보내면 성공합니다.
- **팔로워 1대 장애:** 리더 1대, 팔로워 1대. 총 2개의 복제본이 ISR에 남아 있습니다. `min.insync.replicas=2` 조건을 만족하므로 `acks=all` 요청은 여전히 2대의 확인을 받고 성공적으로 처리됩니다.
- **팔로워 2대 장애:** 리더 1대만 ISR에 남아 있습니다. 이 경우, 최소 요구 조건인 2를 만족하지 못하므로, 프로듀서가 `acks=all`로 보낸 요청은 **성공이 아닌 에러(`NotEnoughReplicas` 또는 `TimeoutException`)를 반환**합니다.

이것은 매우 중요한 정책적 선택입니다. 카프카는 `min.insync.replicas` 설정을 통해, 데이터의 내구성을 보장할 수 없는 위험한 상황이라면 차라리 \*\*쓰기 요청을 실패시켜 데이터의 정합성을 지키는 쪽(일관성)\*\*을 택합니다. 가용성을 약간 희생하더라도 데이터 무결성을 최우선으로 하는 설계 철학이 담겨있는 것이죠.

### **그래서, 우리 서비스엔 뭘 써야 할까?**

지금까지 배운 개념을 바탕으로, 각 서비스의 특성에 맞는 `acks` 옵션을 선택하는 기준을 정리해 보겠습니다.

| acks 옵션  | 추천 사용 사례                                         | 장점 (우선순위)          | 단점 (감수할 점)    |
| -------- | ------------------------------------------------ | ------------------ | ------------- |
| acks=0   | 😫 일부 유실돼도 괜찮은 대규모 데이터 수집\<br/>(로그, 메트릭, 클릭 스트림) | 1. 처리량\<br/>2. 속도  | 신뢰도 (메시지 유실)  |
| acks=1   | 🙂 일반적인 대부분의 서비스\<br/>(알림 발송, 데이터 동기화, 이벤트 처리)   | 1. 균형\<br/>2. 속도   | 낮은 확률의 데이터 유실 |
| acks=all | 😎 데이터 유실이 절대 안 되는 핵심 서비스\<br/>(주문, 결제, 금융 트랜잭션) | 1. 신뢰도\<br/>2. 정합성 | 속도 (지연 시간 증가) |

**한 가지 더!** 신뢰도를 높이기 위해 `acks=all`을 선택했다면, **멱등성 프로듀서(`enable.idempotence=true`)** 옵션을 함께 활성화하는 것이 거의 필수적입니다. `acks=all` 설정에서는 네트워크 오류 등으로 브로커의 응답을 받지 못한 프로듀서가 메시지를 재전송할 수 있는데, 이때 멱등성 옵션이 켜져 있어야 브로커가 중복된 메시지를 알아서 단 한 번만 저장하도록 처리해 줍니다. 이 주제는 추후 'Exactly-Once Semantics'를 다룰 때 더 자세히 이야기해 보겠습니다.

### **마치며: 트레이드오프에 대한 이해**

카프카의 메시지 전송 신뢰도는 단순히 "보장된다" 또는 "안된다"의 이분법적인 개념이 아닙니다. **`acks`와 `min.insync.replicas`** 같은 옵션들을 통해 개발자가 서비스의 요구사항에 맞춰 **지연 시간, 처리량, 내구성 사이의 관계를 능동적으로 조절**할 수 있는 '튜너블(Tunable)' 시스템에 가깝습니다.

우리가 만드는 서비스의 데이터가 얼마나 중요한지, 약간의 유실이 치명적인지, 아니면 속도가 더 중요한지를 명확히 이해하고 그에 맞는 최적의 옵션을 선택하는 것이야말로 카프카를 제대로 활용하는 개발자의 핵심 역량일 것입니다.