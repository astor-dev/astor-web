---
id: "559634244213673985"
author: "Astor"
title: "NestJS DI"
seriesId: "NestJS 심화 활용"
tags:

ogImage: "https://d2r0pavv0lsiqc.cloudfront.net/posts/images/7731f5bf-d58f-4771-a4d9-3894fc503883.webp"
description: "계속 쓸 예정"
pinned: true
draft: true
createdAt: "2025-03-25 15:51:26"
updatedAt: "2025-03-25 15:51:26"
---

의존성 주입(DI, Dependency Injection)은 NestJS의 핵심 설계 철학이자 아키텍처의 근간을 이루는 중요한 개념입니다. 이번 글에서는 NestJS의 DI를 프레임워크 수준에서 심도 있게 분석하며, 실제 활용 가능한 고급 전략까지 자세히 다룹니다.

## 1. NestJS DI의 내부 구조와 원리

흔히 DI라고 하면 사용자 입장에선 아래 처럼 생각합니다.

> Injectable이 붙어있는 놈을 Singletone(혹은 scope에 맞게) Nest가 알아서 넣어주는 것

실제로 동작을 보면 NestJS는 TypeScript의 Reflect Metadata API와 데코레이터를 통해 DI를 구현합니다.

- **Reflect Metadata API**
  : 클래스와 생성자에 메타데이터를 정의하여 런타임에 인스턴스를 동적으로 주입합니다.
- **DI 컨테이너**
  : NestJS가 제공하는 컨테이너는 프로바이더의 라이프사이클을 관리하며, 모듈 컴파일 시점에 프로바이더를 등록하고, 런타임 시에 요청에 따라 인스턴스를 생성 및 반환합니다.

한번 내부 구조를 뜯어보겠습니다.

![](https://d2r0pavv0lsiqc.cloudfront.net/projects/images/ff46c5b2-5e69-4c89-9453-8e055496a017.webp)![](https://d2r0pavv0lsiqc.cloudfront.net/projects/images/ae2f9149-9270-48b8-9109-a35afa64b727.webp)

주석 부분을 대충 요약하면 Injectable은 Provider로 만들어주는 데코레이터이며, Nest에서 Provider는 DI 가능한 요소로 모듈에 들어 있어야 DI가 가능하다 정도로 정의됩니다.

왜 그럴까, 그리고 어떻게 동작할까 코드를 보겠습니다.

```ts
export function Injectable(options?: InjectableOptions): ClassDecorator {
  return (target: object) => {
    Reflect.defineMetadata(INJECTABLE_WATERMARK, true, target);
    Reflect.defineMetadata(SCOPE_OPTIONS_METADATA, options, target);
  };
}
```

Injectable 데코레이터의 기능입니다. 굉장히 심플한데, Reflect를 통해 class의 메타데이터를 마킹합니다. 굉장히 심플하게 메타데이터 마킹만 되면 Provider로 기능한다는 건데, 이 마킹을 어떻게 활용하고 있을까 찾아보겠습니다.

```ts
  private async initialize(
    module: any,
    container: NestContainer,
    graphInspector: GraphInspector,
    config = new ApplicationConfig(),
    options: NestApplicationContextOptions = {},
    httpServer: HttpServer | null = null,
  ) {
    UuidFactory.mode = options.snapshot
      ? UuidFactoryMode.Deterministic
      : UuidFactoryMode.Random;

    const injector = new Injector({ preview: options.preview! });
    const instanceLoader = new InstanceLoader(
      container,
      injector,
      graphInspector,
    );
    const metadataScanner = new MetadataScanner();
    const dependenciesScanner = new DependenciesScanner(
      container,
      metadataScanner,
      graphInspector,
      config,
    );
    //생략
```

NestJS의 app을 만들어주는 nest-factory 클래스의 initialize() 메서드입니다.&#x20;

**injector**, **instanceLoader**, **metadataScanner**, **dependencyScanner**를 차례로 생성합니다.

같은 메서드의 좀 더 아래를 보겠습니다.

```ts
      await ExceptionsZone.asyncRun(
        async () => {
          await dependenciesScanner.scan(module);
          await instanceLoader.createInstancesOfDependencies();
          dependenciesScanner.applyApplicationProviders();
        },
        teardown,
        this.autoFlushLogs,
      );
```

생성한 **dependenciesScanner**를 통해 scan ➡ createInstance ➡ apply 순으로 진행합니다.

Scanner의 scan 메서드를 보겠습니다.

```ts
  public async scan(
    module: Type<any>,
    options?: { overrides?: ModuleOverride[] },
  ) {
    await this.registerCoreModule(options?.overrides);
    await this.scanForModules({
      moduleDefinition: module,
      overrides: options?.overrides,
    });
    await this.scanModulesForDependencies();
    this.addScopedEnhancersMetadata();
    this.calculateModulesDistance();
    this.container.bindGlobalScope();
  }
```

의존성 부분만 좀 더 보면,

```ts
  public async scanModulesForDependencies(
    modules: Map<string, Module> = this.container.getModules(),
  ) {
    for (const [token, { metatype }] of modules) {
      await this.reflectImports(metatype, token, metatype.name);
      this.reflectProviders(metatype, token);
      this.reflectControllers(metatype, token);
      this.reflectExports(metatype, token);
    }
  }
```

reflect들을 호출하고 있습니다. @Module에서 자주보던 imports, providers, controllers, exports들을 확인할 수 있습니다. reflect메서드의 기능은 모두 유사하여 하나만 꼽아 보겠습니다.

```ts
  public reflectProviders(module: Type<any>, token: string) {
    const providers = [
      ...this.reflectMetadata(MODULE_METADATA.PROVIDERS, module),
      ...this.container.getDynamicMetadataByToken(
        token,
        MODULE_METADATA.PROVIDERS as 'providers',
      )!,
    ];
    providers.forEach(provider => {
      this.insertProvider(provider, token);
      this.reflectDynamicMetadata(provider, token);
    });
  }
```

```ts
  public reflectMetadata<T = any>(
    metadataKey: string,
    metatype: Type<any>,
  ): T[] {
    return Reflect.getMetadata(metadataKey, metatype) || [];
  }
```

@Injectable()로 코드에서 마킹해둔 metaData를 읽고 있습니다. 이를 통해 스캐너의 기능은 @Module, @Controller, @Injectable 등 **데코레이터가 붙어있는 코드를 순회**하여 **의존하고 있는 클래스들을 체크**하는 것이라 볼 수 있습니다.

## 2. DI의 주요 개념과 전략

NestJS의 DI는 세 가지 주요 개념을 중심으로 합니다.

### Constructor-based DI

- 의존성은 주로 생성자를 통해 주입되어 명시적이고 관리가 쉽습니다.

### Provider 등록 방식

- `useClass`
  : 클래스 기반 프로바이더
- `useValue`
  : 상수값이나 미리 생성된 객체 제공
- `useFactory`
  : 복잡한 로직이나 환경변수에 따라 동적 객체 제공

### DI Token 전략

- 클래스 자체, 문자열, Symbol, Abstract Class 등 다양한 형태의 DI 토큰을 사용하여 프로바이더를 관리합니다.

## 3. DI Scope 심화 분석

NestJS의 DI Scope는 다음 세 가지로 구분됩니다.

### Singleton Scope (기본)

- NestJS는 기본적으로 모든 프로바이더를 Singleton으로 관리하여 애플리케이션 전체에서 하나의 인스턴스를 공유합니다.

### Request Scope

- 각 요청마다 별도의 인스턴스를 생성하여 상태를 격리합니다.
- 인증, 권한, 로깅 컨텍스트 관리 등 요청별 상태 유지가 필요할 때 사용됩니다.

### Transient Scope

- 요청이나 의존성 주입 시마다 새로운 인스턴스를 생성하여 상태가 유지되지 않도록 합니다.
- 매번 새로운 상태로 초기화가 필요한 프로토타입 객체나 빌더 패턴 활용 시 적합합니다.

### Scope 상호작용과 주의점

- **Singleton에 Request Scoped 인스턴스 주입**
  : 직접 주입은 불가능하며, Injection Scope를 맞춰야 합니다. 해결 방법은 Provider에서 명시적으로 Scope를 지정하거나 
  `Scope.REQUEST`
  의 프로바이더를 사용하는 클래스 자체도 Request Scoped로 설정해야 합니다.

**잘못된 예시:**

@Injectable()
export class SingletonService {
&#x20; constructor(private readonly requestScopedService: RequestScopedService) {} // 오류 발생
}


**올바른 예시:**

@Injectable({ scope: Scope.REQUEST })
export class SingletonService {
&#x20; constructor(private readonly requestScopedService: RequestScopedService) {} // 요청마다 SingletonService도 Request Scope로 생성됨
}


- **Transient의 상호작용**
  : Transient 인스턴스는 요청과 싱글톤 모두에게 주입될 수 있으나, 매 주입 시마다 독립적인 새 인스턴스가 생성됩니다.

## 4. 고급 DI 활용 전략: Abstract Class와 Symbol 기반 DI

- Abstract Class는 런타임에도 유지되므로 추상화 및 테스트 용이성에 탁월하며, 일반적인 DI 전략으로 권장됩니다.
- Symbol 기반 DI는 강력한 고유성으로 런타임 충돌을 방지하며, 복수의 구현체나 모듈 내부에서만 노출될 때 유용합니다.

## 5. DIP(의존성 역전 원칙)의 NestJS 활용법

NestJS에서 DIP는 도메인과 인프라의 의존성을 추상화하는 데 매우 유용한 전략입니다.

- 도메인 레이어에서 포트(Abstract Class)를 정의하고, 인프라 레이어에서 구체적인 어댑터를 구현하는 방식입니다.
- 이를 통해 도메인은 구체적인 구현체가 아닌 추상화된 인터페이스나 Abstract Class에만 의존하게 됩니다.

// 포트
export abstract class IUserRepository {
&#x20; abstract findById(id: string): Promise\<User>;
}

// 어댑터
@Injectable()
export class UserRepositoryAdapter implements IUserRepository {
&#x20; async findById(id: string): Promise\<User> {
&#x20;   return this.prisma.user.findUnique({ where: { id } });
&#x20; }
}


## 6. 실전 예제 및 Best Practices

- **Singleton**
  : 대부분의 비즈니스 로직 서비스, 데이터 접근 레이어
- **Request Scope**
  : 사용자 컨텍스트 서비스, 요청 기반 로깅 서비스
- **Transient**
  : 상태 초기화가 매번 필요한 임시 작업(이메일 발송, 파일 생성 등)

실제 서비스 예:

@Injectable({ scope: Scope.REQUEST })
export class RequestLoggerService {
&#x20; private readonly requestId: string;

&#x20; constructor(@Inject(REQUEST) private request: Request) {
&#x20;   this.requestId = request.headers\['x-request-id'] as string;
&#x20; }
}


## 7. 결론

NestJS에서 DI는 단순한 주입 메커니즘 이상의 아키텍처적 가치를 지닙니다. Scope와 DI 전략을 정확히 이해하고 상황에 맞게 활용하면 유지보수성 높은 유연한 시스템을 구축할 수 있습니다.

***

**태그**: `NestJS`, `DI`, `Dependency Injection`, `Advanced`, `Architecture`, `TypeScript`, `SOLID`, `Design Patterns`, `Scope`, `DIP`

오랑❤️