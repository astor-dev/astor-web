---
id: "638243380781912064"
author: "Astor"
title: "Servlet Container 직접 만들기 - 컴포넌트 설계 및 주요 Servlet API implementation"
pinned: true
draft: false
tags:
  - 네트워크
  - Servlet
  - Java
ogImage: "https://d2r0pavv0lsiqc.cloudfront.net/posts/images/ccf49f65-4701-46d5-abea-cfadca2d87dd.webp"
seriesId: "627035484337475587"
createdAt: "2025-10-27 14:07:19"
updatedAt: "2025-10-28 14:11:19"
---

import LinkPreview from '~common/components/card/link-preview.astro'

Java 애플리케이션에서 개발자가 저수준의 소켓 제어 및 프로토콜 명세에 맞도록 데이터 규격화를 직접 하지 않도록 하기 위해 Java EE에서 **Servlet API라는 표준화된 인터페이스**를 제공합니다. 또한 Servlet API의 구현체를 정의하고, 이를 기반으로 실제 통신을 처리할 수 있도록 하는 런타임을 **서블릿 컨테이너**라고 정의합니다. **Tomcat, Jetty**와 같은 다양한 상용 구현체가 존재합니다.

서블릿 컨테이너의 역할 및 기능을 직접 눈으로 보고 코드로 녹여내보기 위해서, **Servlet API를 직접 구현**하고, 이를 실행하는 **런타임**까지 만든 뒤, 직접 만든 서블릿 컨테이너 위에서 WAS 실행까지 해보겠습니다.

컴포넌트 설계는 톰캣의 구조(catalina, coyote)를 참고하였습니다.&#x20;

아래에서 소스코드를 확인하실 수 있습니다.

<LinkPreview url="https://github.com/astor-dev/bottom-up-java-web/tree/main/2-servlet-container-impl" />

## 컴포넌트 설계

### 요구사항 정의

- **HTTP 프로토콜 지원**: 서블릿 HTTP 인터페이스를 구현하며 버전에 따른 HTTP 프로토콜 명세를 준수해야 하며, 클라이언트로부터 GET, POST 등의 HTTP 요청을 수신하고 적절한 응답(예: 200 OK, 404 Not Found)을 반환할 수 있어야 함. 헤더 처리, 바디 데이터 읽기/쓰기, 멀티파트 요청 지원 등을 포함.
- **서블릿 라이프사이클 관리**: 서블릿 인스턴스의 생성(init), 서비스(service), 소멸(destroy)을 자동으로 관리. 싱글톤으로 효율적으로 서블릿을 재사용하며, 초기화 시 ServletConfig를 제공.
- **요청-응답 매핑**: URL 패턴에 따라 적절한 서블릿을 매핑하고 호출.
- **멀티스레딩 지원**: 다중 클라이언트 요청을 동시에 처리하기 위해 스레드 풀을 사용. 각 요청이 별도의 스레드에서 실행되며, thread-safety를 보장.
- **세션 관리**: HTTP 세션을 지원하여 사용자 상태를 유지. HttpSession 인터페이스를 구현하고, 쿠키나 URL 재작성을 통해 세션 ID를 관리.
- **필터 체인 지원**: 요청/응답을 가로채는 필터를 체인 형태로 적용. 인증, 로깅, 인코딩 등의 전처리/후처리를 가능하게 함.
- **리스너 지원**: 애플리케이션 이벤트(예: 컨텍스트 초기화, 세션 생성/소멸)를 감지하는 리스너(ServletContextListener 등)를 등록하고 호출.
- **웹 애플리케이션 로딩**: 내장 웹서버 방식으로 애플리케이션을 로드. 서블릿 클래스 등록 및 인스턴스화, 별도의 WAR 파일 대신 코드 내에서 직접 등록하거나 설정.
- **표준 준수**: Java Servlet API 사양(예: Jakarta Servlet 6.1)을 준수하여 호환성 보장.
- **네트워크 모듈 지원**: 별도의 네트워크 모듈을 통해 소켓 기반 연결을 처리. 서버 소켓 생성, 클라이언트 연결 수락, 데이터 송수신을 담당하며, 컨테이너와 분리.
- **프로토콜 계층 지원**: 응용 레이어 프로토콜 파싱과 생성을 위한 전용 계층을 구현. 요청 라인, 헤더, 바디를 독립적으로 처리하며, 다른 프로토콜(예: HTTPS) 확장을 고려.
- **계층간 독립성**: 네트워크 모듈과 프로토콜 계층이 서블릿 컨테이너로부터 독립되어야 함. 서블릿은 네트워크 세부 사항이나 프로토콜 구현을 알지 않고, 추상화된 인터페이스만 사용

### 상위 설계

![](https://d2r0pavv0lsiqc.cloudfront.net/projects/images/fc73543e-8b24-4d0f-9fe1-aba2f8469586.webp)

패키지 수준의 상위 컴포넌트 설계입니다. **net 패키지**에서 가장 낮은 수준의 원시 네트워크 통신을 담당합니다. **bridge 패키지**에서는 net 계층으로부터 받은 원시 바이트 스트림을 해석하여 의미 있는 애플리케이션 프로토콜(HTTP/1.1 등) 단위로 변환합니다.

두 패키지는 서블릿 API와 무관하게 설계합니다. 네트워크 및 프로토콜 처리라는 모듈의 고유 책임을 갖고 이를 수행합니다.

### 사용자 인터페이스

```java
public class WebApplication {
    public static void main(String[] args) {
        try (ServletContainer servletContainer = new ServletContainer()) {
            servletContainer.addListener(ContextListener.class);
            servletContainer.addFilter("LoggingFilter", LoggingFilter.class, "/*");
            servletContainer.addServlet("HelloWorldServlet", HelloWorldServlet.class, "/hello");
            servletContainer.addConnector(8080, Endpoint.Type.BIO, Protocol.HTTP11);
            servletContainer.addConnector(8081, Endpoint.Type.NIO, Protocol.HTTP11);
            servletContainer.start();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

사용자(웹 애플리케이션)에서 내장 웹서버 방식으로 서블릿 컨테이너 인스턴스를 생성하고 필터, 리스너, 서블릿을 등록한 후 웹서버를 실행할 수 있도록 합니다.

## net

원시 네트워크 통신을 담당합니다. BIO나 NIO의 구현 차이를 추상화하여 상위 계층에 일관된 인터페이스를 제공합니다.

### Endpoint

```java
public interface Endpoint {
    enum Type {
        BIO, NIO
    }

    void start() throws IOException;

    void stop() throws IOException;

    void bind(int port);

    void setHandler(Handler protocolHandler);
}
```

네트워크 연결을 수신하는 엔드포인트에 대한 인터페이스입니다. 구현체는 특정 I/O 모델(BIO/NIO)을 사용하여 서버 소켓을 열고 클라이언트 연결을 수락합니다. I/O 모델에 대한 다형성을 제공합니다.

시리즈의 이전 글에서 구현한 BIO 소켓을 기본으로 담습니다. 향후 java.nio를 활용해 논블로킹 IO에 대한 확장성을 열기 위해 엔드포인트를 추상화하여 사용합니다.

```java

public class BioEndpoint extends AbstractEndpoint {
    private ServerSocket serverSocket;

    @Override
    public void start() throws IOException {
        serverSocket = new ServerSocket(port);
        executor.submit(() -> {
            System.out.println("started Bio Server Socket at port: " + port);
            while (true) {
                try {
                    Socket socket = serverSocket.accept();
                    SocketWrapperBase wrapper = new BioSocketWrapper(socket);
                    executor.submit(() -> handler.process(wrapper));
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        });
    }

    @Override
    public void stop() throws IOException {
        super.stop();
        if (serverSocket != null && !serverSocket.isClosed()) {
            serverSocket.close();
        }
    }
}
```

서버 소켓측 구현은 표준적인 BIO 서버소켓 사이드 코드로 만들었습니다. accept된 소켓을 별도의 스레드를 풀에서 가져와서 핸들러 로직을 실행시킵니다.

### Handler

```java
public interface Handler {
    boolean process(SocketWrapperBase socketWrapper);
}
```

소켓의 요청을 처리할 Handler에 대한 인터페이스를 정의해둡니다.

## bridge

net 계층과 container 계층을 연결하는 다리 역할을 합니다. net 계층으로부터 받은 원시 바이트 스트림을 해석하여 애플리케이션 프로토콜을 핸들링합니다.

### ProtocolHandler

```java
public abstract class ProtocolHandler implements Handler, AutoCloseable {
    protected Endpoint endpoint;

    protected Endpoint getEndpoint() {
        return this.endpoint;
    }

    @Override
    public void close() throws Exception {
        this.endpoint.stop();
    }
}
```

`Endpoint` 를 지니며 Endpoint로 부터 맺어진 통신을 특정 프로토콜로 해석 및 처리하며 생명주기를 관리합니다.

```java
import java.io.IOException;

public class Http11Protocol extends ProtocolHandler {

    private final Gateway gateway;
    private final int port;

    public Http11Protocol(Gateway gateway, Endpoint.Type type, int port) {
        this.gateway = gateway;
        switch (type) {
            case NIO -> this.endpoint = new NioEndpoint();
            case BIO -> this.endpoint = new BioEndpoint();
        }
        this.port = port;
        init();
    }

    @Override
    public boolean process(SocketWrapperBase socketWrapper) {
        Http11Processor processor = new Http11Processor(socketWrapper, gateway);
        return processor.process();
    }

    private void init() {
        this.endpoint.setHandler(this);
        this.endpoint.bind(port);
        try {
            this.endpoint.start();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}

```

HTTP/1.1 프로토콜을 핸들링하는 구현체입니다. 전체 생명주기 관장을 하며 요청 파싱 및 처리는 Http11Processor 클래스가 담당합니다.

![](https://d2r0pavv0lsiqc.cloudfront.net/projects/images/b72a3164-d0cb-4274-8836-79cf16115969.webp)

Processor는 소켓의 스트림을 파싱하고 서빙합니다.

### Gateway

```java
public interface Gateway {
    void service(Request request, Response response);
}

```

Bridge 계층에서 파싱한 Request와 Response를 인자로 받으며 상위 컴포넌트에서 로직을 처리할 수 있게 해주는 Bridge 계층의 관문(Gateway) 입니다.

## container

가장 상위 계층으로, Jakarta Servlet 명세를 구현합니다. 서블릿의 생명주기 관리, 요청-서블릿 매핑, 필터 체인 적용, 세션 관리 등 웹 애플리케이션의 핵심 로직을 담당합니다.

### Connector

bridge 계층과 container 계층을 최종적으로 연결합니다. **프로토콜 및 네트워크에 대한 로직을 응집**해서 처리합니다.

```java
public class Connector implements AutoCloseable{
    private final Gateway gateway;
    private final ProtocolHandler protocolHandler;
    public final int port;
    public final String protocol;
    public final String scheme;

    public Connector(Protocol protocol, Context context, int port, Endpoint.Type type) {
        this.gateway = new BridgeGateway(context, this);
        this.port = port;
        switch (protocol) {
            case HTTP11 -> {
                this.protocolHandler = new Http11Protocol(gateway, type, port);
                this.protocol = "HTTP/1.1";
                this.scheme = "http";
            }
            default -> throw new UnsupportedOperationException();
        }
    }
// 생략
}
```

connector 개념으로 네트워크 영역을 응집시킨 덕에, 나머지 서블릿 관련 로직들은 네트워크 무관하게 재사용될 수 있습니다.

가령 아래와 같이 등록하고 서버를 키면 `localhost:8080`과 `localhost:8081`에서 각기 다른 형식으로 구현된 서버소켓이 돌아가서 두 포트 모두 요청을 받을 수 있으며 실제 처리로직은 공유된 내부 인스턴스 및 서블릿이 담당합니다.

```java
servletContainer.addServlet("HelloWorldServlet", HelloWorldServlet.class, "/hello");
servletContainer.addConnector(8080, Endpoint.Type.BIO, Protocol.HTTP11);
servletContainer.addConnector(8081, Endpoint.Type.NIO, Protocol.HTTP11);
servletContainer.start();
```



![](https://d2r0pavv0lsiqc.cloudfront.net/projects/images/83f4caab-7c3d-4e1c-a517-2fb4de394512.webp)![](https://d2r0pavv0lsiqc.cloudfront.net/projects/images/7e41f246-b3e4-434a-b37f-c1b43edb8c7b.webp)![](https://d2r0pavv0lsiqc.cloudfront.net/projects/images/995d3e30-9b36-4941-8e4f-7fec0ac50014.webp)

> 각기 다른 네트워크 설정에서 서버 소켓이 열리며 비즈니스 로직을 재활용하는 모습

### BridgeGateway

```java

public class BridgeGateway implements Gateway {
    private final Context context;
    private final ServletMapper servletMapper;
    private final FilterMapper filterMapper;
    private final Connector connector;


    public BridgeGateway(Context context, Connector connector) {
        this.context = context;
        this.servletMapper = context.getServletMapper();
        this.filterMapper = context.getFilterMapper();
        this.connector = connector;
    }

    @Override
    public void service(Request request, Response response)  {
        HttpRequest httpRequest = connector.createRequest(request, context);
        HttpResponse httpResponse = connector.createResponse(response);
        httpRequest.setResponse(httpResponse);

        fireRequestInitializedEvent(httpRequest);

        try {
            String requestURI = request.getRequestURI();
            Servlet servlet = servletMapper.map(requestURI);
            List<Filter> filters = filterMapper.getMatchingFilters(requestURI);

            ApplicationFilterChain filterChain = new ApplicationFilterChain(filters, servlet);
            filterChain.doFilter(httpRequest, httpResponse);

            if (servlet != null) {
                httpResponse.flushBuffer();
            } else {
                httpResponse.sendError(HttpServletResponse.SC_NOT_FOUND, "Not Found");
            }
        } catch (ServletException | IOException e) {
            throw new RuntimeException(e);
        } finally {
            fireRequestDestroyedEvent(httpRequest);
        }
    }
// 생략
}
```

`bridge.Gateway` 인터페이스의 구현체로, 컨테이너의 실질적인 진입점입니다. `bridge` 계층에서 파싱된 `bridge.Request`와 `bridge.Response`를 받아, 이를 서블릿 API 표준인 `HttpServletRequest`와 `HttpServletResponse`로 변환한 후, 적절한 서블릿과 필터 체인을 찾아 호출합니다.

### Context

하나의 웹 애플리케이션 컨텍스트를 구성하는 요소들을 포함합니다.

```java
public class Context {
    private final CustomServletContext servletContext;
    private final SessionManager sessionManager;
    private ServletMapper servletMapper;
    private FilterMapper filterMapper;
    private final Map<String, Servlet> instantiatedServlets = new ConcurrentHashMap<>();
    private final Map<String, Filter> instantiatedFilters = new ConcurrentHashMap<>();
  // 생략
}
```

Servlet API의 `ServletContext`, `ServletRegistration`, `HttpSession`, `Filter` 등의 인스턴스를 갖고 있으며 getter과 setter를 제공합니다.