---
author: "Astor"
title: "NestJS - 도메인 주도 설계(1)"
series: "NestJS 심화 활용"
tags:
  - NestJS
  - 개발철학
  - DDD
ogImage: "https://d2r0pavv0lsiqc.cloudfront.net/posts/images/68ea1eba-a89f-477e-91c5-224757de2f10.jpeg"
description: "NestJS 프레임워크로 도메인 주도 설계의 '전술적 설계'를 담아내는 방법을 설명합니다."
pinned: true
draft: false
createdAt: "2025-02-26 19:06:58"
updatedAt: "2025-02-26 19:06:58"
---

## 시작하며: 도메인 주도 설계란?

도메인 주도 설계(DDD)는 비즈니스의 인사이트를 소프트웨어 개발에 녹여내는 방법론입니다. *유비쿼터스 언어(Ubiquitous Language)*, *바운디드 컨텍스트(Bounded Context)* 등의 개념을 핵심으로 하며, 크게 **전략적 설계**와 **전술적 설계**로 나뉩니다.

이번 포스트에서는 NestJS 프레임워크로 **전술적 설계**를 어떻게 적용할 수 있는지에 초점을 맞추고자 합니다. 만약 DDD 자체가 생소하다면, 본 포스트에 앞서 DDD 개념을 한 번 더 공부해보시는 것을 권장합니다. 추후 DDD 전반에 걸친 시리즈 글로 개념을 더 자세히 다룰 예정이니 많은 기대 부탁드립니다.

## 전술적 설계에서 활용할 개념

### 1. 바운디드 컨텍스트(Bounded Context)

`바운디드 컨텍스트`는 DDD의 전략적 설계에서 가장 핵심적인 요소 중 하나입니다.

- **의미**
  : 말 그대로 “경계가 정해진 컨텍스트”를 의미합니다. 여기서 ‘경계’(Boundary)는 하나의 도메인을 다른 도메인과 분리해주는 역할을 합니다.
- **역할**
  : 각 컨텍스트 내부에서만 유효한 
  **유비쿼터스 언어(Ubiquitous Language)**
  를 정립하고, 이를 기반으로 도메인 모델을 정의하여 혼란을 최소화합니다.
- **중요성**
  : 여러 팀 혹은 여러 기능이 뒤섞이는 대규모 프로젝트에서는, 각 팀이 맡은 컨텍스트(도메인)를 명확히 구분해야 의사소통이 쉬워지고, 모델 충돌을 방지할 수 있습니다.

예를 들어, “예약 시스템”을 구축한다고 가정해 봅시다.

- **예약(Reservation)**
   컨텍스트와 
  **결제(Payment)**
   컨텍스트가 각각 존재할 수 있습니다.
- 결제 컨텍스트가 예약 컨텍스트의 도메인 객체를 직접 참조하기보다는, 
  **API**
  나 
  **이벤트**
  를 통해 느슨하게 필요한 정보만 주고받도록 설계하는 것이 바운디드 컨텍스트의 핵심입니다.

이렇게 **바운디드 컨텍스트**를 먼저 나눈 뒤, 내부에 어떤 엔티티, 어떤 값 객체, 어떤 서비스가 필요한지 정의해 나가는 것이 전술적 설계의 출발점이 됩니다.

### 2. 엔티티와 값 객체

- **엔티티(Entity)**
  : 고유한 식별자
  **(ID)**
  를 가진 객체로, 시간이 지나도 동일성을 유지합니다. 
  `예약`
   그 자체가 엔티티가 될 수 있겠네요.
- **값 객체(Value Object)**
  : 불변의 특성을 가지며, 단순히 값 자체로서 의미를 갖는 객체입니다. 
  `예약`
  에서 price에 대한 정보들을 
  `reservationPrice`
   라는 값 객체로 따로 정의할 수 있습니다.

### 3. 애그리거트

- **애그리거트(Aggregate)**
  : 관련 있는 엔티티와 값 객체를 하나의 단위로 묶어, 외부와의 경계를 명확히 하는 역할을 합니다. 이를 통해 데이터의 일관성을 유지할 수 있습니다. 가령 
  `User`
   애그리거트에서는 
  `UserProfile`
  , 
  `UserProgress`
  등의 엔티티가 존재할 수 있습니다.
- **애그리거트 루트(AggregateRoot)**
  : aggregate의 중심이 되는 하나의 객체를 뜻합니다. 보통 AggregateRoot가 같은 Aggregate 내부 여러 엔티티들을 향한
   
  **단일 진입점**
   역할을 합니다. 
  `User`
  클래스가  
  `User`
   애그리거트의 여러 엔티티를 아우르는 Root가 될 수 있죠.
- **도메인 이벤트(Domain Event)**
  : 도메인에서 특정 (도메인) 로직을 수행하면서 발생하는 중요한 사건을 표현합니다. 가령 유저가 생성 되었을 때, 
  `유저 생성됨`
   이벤트가 발행될 수 있습니다. 유저 생성이라는 로직과 연관되어 움직여야할 외부 도메인에선, 해당 이벤트를 구독함으로 느슨한 결합을 유지하며 외부 도메인과 연관된 로직을 유지할 수 있죠.

## NestJS-프로젝트 셋업하기

아래와 같이 DDD 기반으로 NestJS 프로젝트의 디렉토리 구조를 설계할 수 있습니다. `service` 디렉토리는 Bounded Context별로 나누고, 추후 개별 마이크로 서비스로의 전환을 도모합니다.  `shared` 디렉토리는 공통 모듈을 포함하는 구조로 설계합니다.

```json
src
├── service
|   | tutorial
│   ├── command
│   │   ├── aggregates
│   │   ├── applications
│   │   ├── infrastructures
│   │   ├── presentations
│   │   ├── tutorial.command.module.ts
│   ├── query
│   │   ├── application
│   │   ├── infrastructure
│   │   ├── presentations
│   │   ├── tutorial.command.module.ts
|   ├── tutorial.module
├── shared
│   ├── common
│   ├── domain
│   ├── infrastructure
│   ├── interfaces
│   ├── utils
├── main.ts
├── app.module.ts
```

service외의 디렉토리는 각자 취향에 맞게 설계하시면 됩니다. 우선 하나하나 설명을 하기 앞서 Command와 Query를 나눈 이유는 읽기와 쓰기 책임을 나눈다는 `CQRS` 패턴을 적용한 것인데, 이에 대해는 여기서 다루기 방대해 아티클을 따로 쓰도록 하겠습니다.&#x20;

나누게 된 이유를 간략하게 설명하면, 도메인 주도 설계의 가장 큰 효용은 쓰기 작업 등을 수행할 때 도메인 모델을 기점으로 각각 데이터를 안정적인 생명주기로 다룰 수 있다는 건데, **읽기 작업에선 Domain 계층을 활용하는 것이 쓸모가 정말 없습니다.** 오히려 여러 도메인과 관련된 정보를 한번에 쿼리해와야 할 때, 각각 도메인들이 분리가 된 경우 따로따로 불러와야되어 많은 오버헤드가 발생합니다.

DDD는 백엔드 아키텍처가 아니라, 기획부터 개발까지 이어지는 설계 전략인지라, query에서 DDD를 하지 않는다는 것은 아닙니다만, 조회 로직의 특성상 쓰기 작업과는 좀 다른 형태로 전술적 설계가 되어야 합니다.&#x20;

사실상 저희가 지금 이 포스트에서 다루려는건, **쓰기 작업에서의 DDD 구현**이라는 것을 인지해주시기 바랍니다.

### Layered Architecture

기본적으로 여느 백엔드가 그러하듯 layered Architecture를 채택합니다. 계층은 아래와 같이 나눕니다.

- **Applications**
  : 응용 서비스 계층
- **Infrastructures**
  : 외부 인프라(db, queue 등)와 맞닿는 계층
- **presentations**
  : 서버가 외부에 표현되는 계층 (rest controller, rpc controller 등)
- **domain**
  : AggregateRoot, Domain Entity, VO 등 도메인과 관련된 계층


service 내부를 보시면 domain 계층은 안보이는 걸 확인하실 수 있는데, domain 계층은 aggregates 내부에 각각의 모듈을 설계하며 사용합니다.



.. 추후 더 작성 예정