---
id: "599530361046700032"
author: "Astor"
title: "static 키워드의 메커니즘 해부: Java·Kotlin·Python·TypeScript의 차이와 핵심 원리"
pinned: true
draft: true
tags:
  - OOP
  - Java
  - Kotlin
  - Python
  - Typescript
  - 프로그래밍 언어
ogImage: "https://d2r0pavv0lsiqc.cloudfront.net/posts/images/aecb0bcf-bea6-481e-afd2-dc45c9fcf36f.webp"
seriesId: "560288573652209699"
createdAt: "2025-07-13 18:19:36"
updatedAt: "2025-07-13 18:19:36"
---

## 시작하며: 시리즈 집필의 계기

AI를 활용한 코딩이 일상화되면서, 더 이상 **특정 언어의 API나 문법에 대한 ‘암기’가 개발자의 핵심 역량이 되진 않는 시대**가 되었습니다. 이제는 “어떤 자료구조를 쓰겠다”, “이런 방식으로 구성하겠다”는 정도의 아이디어만 정리하면, AI가 문법과 구현은 대부분 완성해줍니다.

더불어, 언어들 자체도 점차 닮아가고 있습니다. 각 언어가 가진 고유한 문법 차이보다는, 객체지향 프로그래밍(OOP)이라는 공통 패러다임 아래 구조적 유사성이 강해졌습니다. 특히 실무에서 주력으로 사용되는 TypeScript, Java, Kotlin, Python 네 언어는 모던한 문법과 도구 지원을 바탕으로, 빠르게 수렴 중입니다.

이런 맥락에서 이제 중요한 것은 개별 언어의 경험적 숙련이 아니라, **언어를 관통하는 핵심 메커니즘에 대한 깊은 이해**입니다. 이 시리즈는 각 언어에서 동일한 개념이 어떻게 구현되고, 어떤 철학을 기반으로 설계되었는지를 분석해보려 합니다.

***

## 도입: static이란?

`static`은 객체지향 언어를 배울 때 가장 먼저 마주치는 키워드 중 하나입니다. 클래스 수준에서 정의되지만, 클래스의 인스턴스와는 별개로 동작하며, 상태를 공유하거나 유틸리티 메서드를 구현할 때 자주 사용됩니다.

하지만 이 단순해 보이는 키워드는 언어마다 해석이 다르고, 내부적으로 작동하는 방식도 제각각입니다.
어떤 언어는 이를 명시적 키워드로 선언하고, 어떤 언어는 싱글톤 객체나 데코레이터로 대체합니다.
또 어떤 언어는 정적 바인딩을 통해 컴파일 타임에 결정되며, 어떤 언어는 런타임 싱글톤 객체로 처리합니다.

이 글에서는 Java, Kotlin, Python, TypeScript 네 언어를 기준으로 `static` 키워드가 어떤 방식으로 표현되고 구현되는지, 그리고 그 배경에 깔린 언어 설계 철학은 무엇인지를 깊이 있게 분석해보겠습니다.

### Java의 static 키워드: 메커니즘과 예외적 활용

Java에서 `static` 키워드는 클래스 로딩 시점에 JVM의 메서드 영역(Method Area)에 정적으로 할당되는 **클래스 수준 멤버**를 선언할 때 사용됩니다.
하지만 표면적인 “클래스 멤버”라는 정의만으로 static의 실제 동작을 설명하긴 부족합니다.
실제로는 상속, shadowing(은닉), 정적 초기화, 동적 로딩, 접근 제한 등 다양한 메커니즘이 얽혀 있습니다.

### 1. 메모리 구조와 static

- **메서드 영역(Method Area)**
  static 필드는 클래스 로딩 시 JVM 메서드 영역에 단 한 번 할당되며, 이후 모든 인스턴스가 동일한 메모리 주소의 값을 공유합니다. 이는 곧 static 필드에 상태가 축적될 경우, **멀티스레드 환경에서 동기화 이슈**가 발생할 수 있음을 의미합니다.
- **클래스 로딩 시점**
  static 멤버는 클래스를 최초로 참조하는 순간(예: 인스턴스 생성, static 필드 접근, Class.forName) JVM에 의해 할당됩니다. 즉, **반드시 인스턴스가 생성된 시점과 일치하지 않음**에 주의해야 합니다.

***

### 2. static 초기화 블록과 순서

```java
class Foo {
    static int a = initA();
    static int b;

    static {
        b = 20;
    }

    static int initA() {
        return 10;
    }
}

```

static 필드 및 static 블록은 **클래스 로딩 시점에, 선언 순서대로** 실행됩니다.

만약 static 블록 내에서 예외가 발생하면, 해당 클래스는 **로딩 자체가 실패**하여 **NoClassDefFoundError**가 발생할 수 있습니다.

### 3. static의 상속과 shadowing(은닉)

Java에서 static 멤버는 인스턴스가 아닌 클래스에 종속됩니다.
하지만 **상속 관계**에서 static 필드/메서드가 어떻게 동작하는지는 오해의 소지가 많습니다.

```java
class Parent {
    static String who = "parent";
    static void hello() { System.out.println("parent"); }
}

class Child extends Parent {
    static String who = "child";
    static void hello() { System.out.println("child"); }
}

Parent p = new Child();
System.out.println(p.who);     // parent
p.hello();                     // parent
System.out.println(Child.who); // child
Child.hello();                 // child

```

#### 여기서의 트릭:

- **static 필드/메서드는 ‘참조 변수의 타입’에 따라 바인딩**됩니다.
  실제 인스턴스 타입이 아닌 **정적 타입**(컴파일 타임에 결정) 기준입니다.
  → 이를 **static shadowing(정적 은닉)**&#xB77C;고 부릅니다.
- **오버라이딩(override)이 아니라, 은닉(hide)일 뿐**이며,
  인스턴스 메서드와 다르게 동적 바인딩이 전혀 일어나지 않습니다.

***

### 4. 정적 import와 네임스페이스 오염

Java 5부터는 `import static` 구문으로 static 멤버를 직접 import할 수 있습니다.

```java
import static java.lang.Math.*;

double r = sqrt(9); // Math.sqrt 생략 가능

```

하지만 static import를 남용하면 이름 충돌(Name Collision)의 위험이 커집니다.

```java
import static java.lang.Math.*;
import static java.lang.Integer.*;

public class Test {
    public static void main(String[] args) {
        System.out.println(MAX_VALUE); // Integer.MAX_VALUE
        // 만약 동일 이름의 static 멤버가 여럿 있으면 컴파일 에러
    }
}

```

***

### 5. static 내부 클래스(정적 중첩 클래스)와 외부 참조

static 내부 클래스는 외부 클래스의 인스턴스 없이도 생성이 가능합니다.

```java
class Outer {
    static class Inner {
        static int x = 42;
    }
}

Outer.Inner in = new Outer.Inner();
System.out.println(Outer.Inner.x); // 42

```

- 정적 중첩 클래스는 **외부 인스턴스 참조를 가질 수 없으며**, 일반 중첩 클래스(Inner Class)와 달리 **메모리 누수 위험이 낮음**
  → **JVM은 static 내부 클래스와 외부 클래스의 메모리를 완전히 분리해서 관리**합니다.

***

### 6. static과 동적 로딩의 교차

클래스가 명시적으로 로딩되는 경우,
static 블록이 언제 실행되는지에 따라 예측 불가한 버그가 발생할 수 있습니다.

```
Class.forName("com.example.SomeClass");

```

- 위 코드에서 `SomeClass`의 static 블록이 실행되어 부수효과(side-effect)가 발생할 수 있음.
- **Reflection 기반 프레임워크에서 의도치 않은 static 초기화 버그**가 자주 발생함.

***

### 7. 예외적 활용 사례와 트릭

- **싱글톤 구현**
  static 필드를 사용해 private 생성자 + static 인스턴스 방식으로 싱글톤을 구현할 수 있음.
- **상수 정의**
  static final 필드는 자바에서 상수(constant)로 활용.
  단, 불변 객체에 대한 reference라도 reference 자체만 final임을 주의해야 함.
- **유틸리티 클래스**
  모든 메서드가 static이고, 생성자를 private으로 막아 인스턴스 생성을 방지.
- **ThreadLocal**
  static ThreadLocal 필드를 사용하면, 스레드별 격리된 값을 유지할 수 있으나, static 필드와 ThreadLocal의 생명주기 및 메모리 누수에 주의 필요.

***

### 8. static 동시성 이슈

static 필드는 모든 인스턴스에서 공유되므로,
멀티스레드 환경에서는 **synchronized** 키워드나 **Atomic 클래스** 등 동시성 제어가 반드시 필요합니다.

```java
class Counter {
    static int count = 0;
    static synchronized void inc() { count++; }
}

```

\[이미지: static 필드에 여러 스레드가 접근하는 다이어그램]

### 결론

Java의 static은 단순한 ‘클래스 멤버’를 넘어서,
클래스 로딩, 메모리 모델, 상속/은닉, 네임스페이스, 초기화 타이밍, 동시성 등 **언어의 깊은 메커니즘**과 직결됩니다.
실제로 면접이나 시험에서는 static의 상속/은닉, 초기화 순서, ThreadLocal 등 엣지케이스가 자주 트릭 문제로 등장합니다.

이러한 관점에서 static을 해부적으로 접근하는 것은
Java의 내부 구조를 근본적으로 이해하는 출발점이 될 수 있습니다.

네, 알겠습니다.
이번에는 \*\*Kotlin의 static 대체 메커니즘(Companion Object 및 정적 관련 구조)\*\*를
메커니즘적, 예외적 사례 위주로 Java 챕터와 동일한 깊이와 논조로 해설합니다.

***

## Kotlin의 static: Companion Object와 객체지향적 대체

Kotlin은 **static 키워드를 제거한 대표적인 JVM 언어**입니다.
그렇다면 Kotlin에서 ‘클래스 단위의 멤버’, 즉 Java의 static은 어떻게 구현되는가?
Kotlin이 택한 방식은 단순한 문법적 대체가 아니라, JVM 메커니즘 위에 객체지향 설계 철학을 얹은 형태입니다.

### Companion Object의 메커니즘

Kotlin에서 static 멤버가 필요한 상황에서는 **companion object**(동반 객체)라는 특수한 싱글톤 객체가 클래스 내부에 선언됩니다.

```kotlin
class Counter {
    companion object {
        var count = 0
        fun reset() { count = 0 }
    }

    init {
        count++
    }
}

```

**companion object의 진짜 의미는 다음과 같습니다.**

- 클래스가 로딩될 때마다, 클래스 당 단 하나의 인스턴스(companion object)가 생성된다.
- 이 companion object는 클래스의 정적 멤버처럼 사용되지만, 사실은 런타임에 생성된 실제 객체다.
- 클래스명.필드, 클래스명.메서드 형태로 접근할 수 있지만, 내부적으로는 `Counter.Companion.count` 식의 싱글톤 객체 참조로 변환된다.

**\[이미지: JVM 바이트코드 상에서 Counter$Companion 클래스가 생성되는 구조]**

### Java Interop, @JvmStatic, 그리고 진짜 static

Kotlin의 companion object는 자바로 컴파일될 때 `Counter$Companion` 내부 클래스로 바이트코드가 생성됩니다.
이 구조는 Java 코드에서 직접적으로 static 멤버처럼 호출할 수 없습니다.
이를 보완하기 위해 Kotlin은 `@JvmStatic` 어노테이션을 제공합니다.

```kotlin
companion object {
    @JvmStatic fun reset() { count = 0 }
}

```

이 어노테이션이 붙은 함수만 자바에서 `Counter.reset()`처럼 바로 호출할 수 있습니다. 정리하자면, **Kotlin은 static 키워드를 지원하지 않지만**, **JVM 호환성을 위해 `@JvmStatic`으로 실제 static 바이트코드를 생성**합니다. 그 외의 멤버는 항상 Companion 싱글톤 객체를 통해서만 접근 가능하다.

### object 선언과 Top-level 함수의 정적화

Kotlin의 객체지향적 static의 또 다른 특징은 **object 선언**입니다.
클래스 외부에 `object` 키워드로 선언하면 그 자체가 애플리케이션 전체에서 하나만 존재하는 싱글톤이 됩니다.

```java
object MathUtils {
    fun add(a: Int, b: Int) = a + b
}

```

`MathUtils.add(1,2)`처럼 호출합니다.
이 object 선언은 실제로 JVM에서 static 영역에 올라가는 싱글톤 객체로 취급됩니다.

또한, Kotlin의 top-level 함수(패키지 레벨에 직접 선언된 함수와 프로퍼티)는 컴파일 시 자동으로 static 멤버로 변환됩니다. 즉, 파일명Kt라는 클래스로 컴파일되어, 자바에서 static 메서드처럼 호출할 수 있습니다.

### Companion Object의 상속, 다형성, Shadowing

companion object도 내부적으로는 일반 객체이기 때문에, 인터페이스 구현 및 상속, 다형성 활용이 가능합니다. 하지만 한 클래스 당 companion object는 하나만 선언할 수 있고, 상속 자체는 불가합니다.

예외적 활용 및 트릭:

- companion object 내부에 인터페이스를 구현시켜 팩토리 패턴 등을 적용할 수 있다.
- companion object도 이름을 명시적으로 줄 수 있다.
- companion object와 object 선언을 동시에 사용할 때, 네임스페이스 충돌을 주의해야 한다.

```kotlin
interface Factory<T> {
    fun create(): T
}
class Product {
    companion object : Factory<Product> {
        override fun create() = Product()
    }
}

```

위 코드는 Product.Companion.create()로 팩토리 역할을 수행합니다.

***

### 정적 초기화와 부작용

companion object의 초기화 블록은 클래스가 처음 참조되는 시점에 한 번만 실행됩니다.
초기화 블록에서 예외가 발생할 경우, Java static 블록과 동일하게 클래스 로딩 자체가 실패할 수 있습니다.

```kotlin
class Example {
    companion object {
        init {
            if (System.currentTimeMillis() < 0) {
                throw IllegalStateException("Impossible")
            }
        }
    }
}

```

***

### 멀티스레드와 동시성

companion object의 멤버도 JVM에서 단일 인스턴스로 동작하므로, 멀티스레드 환경에서
동시성 문제가 발생할 수 있습니다.
동기화가 필요한 경우, Java와 동일하게 synchronized 키워드를 씁니다.

### 요약 및 해석

Kotlin의 static 대체 구조는 단순한 문법 대체가 아닙니다.
런타임 객체(싱글톤)와 JVM 바이트코드 레벨의 호환성, 그리고 객체지향적 다형성을 절충합니다.

static 멤버와는 달리 객체로 취급되기 때문에, 리플렉션, 인터페이스 구현, 이름 지정 등에서 유연함을 가집니다.

반면, static 바이트코드 호환성을 위해 `@JvmStatic` 어노테이션과 top-level 함수/프로퍼티의 정적화 트릭이 존재합니다.

결국, Kotlin의 companion object는,

객체지향적 설계와 JVM의 유산을 동시에 포용하기 위한, 메커니즘적 타협이자, 타입 시스템과 런타임 철학이 맞닿은 핵심 구조라 할 수 있습니다.



### 3. Python의 static: Decorator

Python은 전통적인 static 키워드를 사용하지 않고 데코레이터를 사용해 비슷한 효과를 얻습니다.

```python
class Counter:
    count = 0

    @staticmethod
    def reset():
        Counter.count = 0

    def __init__(self):
        Counter.count += 1

c1 = Counter()
c2 = Counter()
print(Counter.count) # 2
Counter.reset()
print(Counter.count) # 0

```

Python의 staticmethod는 다음과 같은 특성이 있습니다:

- **단순함**: 인스턴스(self)나 클래스(cls)에 대한 레퍼런스를 자동으로 전달하지 않으므로, 단순히 클래스 내의 독립적인 함수를 표현할 때 쓰입니다.
- **클래스 메서드(@classmethod)와의 차이**
  - `@staticmethod`: 클래스 상태에 직접 접근 시 클래스명을 직접 명시해야 함
  - `@classmethod`: 첫 번째 인자로 `cls`를 받아 클래스 상태를 변경할 수 있어, 상속 상황에서도 활용 가능

```python
@classmethod
def reset(cls):
    cls.count = 0

```

Python은 언어의 특성상 클래스가 느슨한 네임스페이스에 가까워, 메모리 관리나 바인딩 같은 하부 메커니즘이 상대적으로 투명한 편입니다.

### 4. TypeScript의 static 키워드

TypeScript의 static은 ECMAScript의 클래스 문법을 그대로 따릅니다.

```ts
class Counter {
    static count = 0;

    constructor() {
        Counter.count++;
    }

    static reset() {
        Counter.count = 0;
    }
}

let c1 = new Counter();
let c2 = new Counter();
console.log(Counter.count); // 2
Counter.reset();
console.log(Counter.count); // 0

```

특징은 다음과 같습니다.

**JS 컴파일 결과**: static 멤버는 프로토타입(prototype)이 아닌, 클래스 생성자 함수 자체에 직접 붙습니다.

```ts
function Counter() { Counter.count++; }
Counter.count = 0;
Counter.reset = function () { Counter.count = 0; };

```

**런타임 특성**: JS 런타임 엔진(V8 등)이 Counter를 로딩할 때 Counter 객체에 직접 속성으로 할당됩니다. 메모리는 힙(heap) 영역에 위치합니다.
\[이미지: JS 엔진이 클래스의 static 멤버를 메모리에 저장하는 구조]

## 마무리: static의 메커니즘 비교 정리

| 특성           | Java            | Kotlin           | Python                   | TypeScript(JS) |
| ------------ | --------------- | ---------------- | ------------------------ | -------------- |
| 메모리 위치       | JVM Method Area | JVM Method Area  | 힙(Heap)                  | 힙(Heap)        |
| 바인딩 방식       | 정적 바인딩          | 런타임 싱글톤 객체       | 런타임 데코레이터                | 런타임 객체 프로퍼티    |
| 키워드 형태       | static          | companion object | @staticmethod            | static         |
| 상속/다형성 지원 여부 | 불가 (정적 바인딩)     | 부분적 지원 가능        | 제한적 지원(@classmethod로 가능) | 제한적 지원         |
| 철학/패러다임      | 클래스 중심의 상태 관리   | 객체지향적 싱글톤 접근     | 네임스페이스 중심의 유연성           | ES6 클래스 구조 준수  |

static은 각 언어가 클래스의 상태를 다루는 방식과 메모리 관리 전략을 보여주는 훌륭한 지표입니다. 이 비교를 통해 각 언어의 설계 철학과 내부 메커니즘을 이해하는 데 한 걸음 더 가까워졌길 바랍니다.

이 글이 이후 클래스 구조와 상속, 다형성 등의 주제를 탐구하는 데도 좋은 출발점이 되길 기대합니다.