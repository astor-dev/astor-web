---
id: "595495016655228928"
author: "Astor"
title: "NestJS 모듈 시스템에 맞춘 계층형 모놀리식 아키텍처 설계"
pinned: false
draft: false
tags:
  - NestJS
  - 아키텍처
  - OOP
  - 디자인
ogImage: "https://d2r0pavv0lsiqc.cloudfront.net/posts/images/43b5d07c-0d7b-4550-9565-b69d47bf224b.webp"
seriesId: "549808096239681536"
createdAt: "2025-07-02 15:04:35"
updatedAt: "2025-07-02 15:04:35"
---

## 시작하며: NestJS와 아키텍처

NestJS는 Node.js 생태계에서 보기 드물게, **강력한 객체지향 기반의 설계 철학**을 갖춘 백엔드 프레임워크입니다. Angular에서 영향을 받은 구조와 함께, 실질적으로는 **Spring Framework에 가까운 모듈 기반 구조와 DI(Dependency Injection) 컨테이너**, 그리고 **데코레이터 중심의 선언적 구성 방식**을 갖추고 있습니다.

하지만 NestJS는 Spring과는 다릅니다.
Spring이 `@Bean`, `@ComponentScan` 등의 클래스 스캐닝 기반 설정과 **런타임 리플렉션 기반의 자동 조립**을 전제로 한다면, NestJS는 **정적이고 명시적인 모듈 시스템**을 중심으로 구성됩니다. **클래스를 어떤 모듈에서 등록하고, 어디에 의존하는지 명확히 선언해야만 동작**하며, 이는 추상적인 객체 생성보다는 **구조적으로 모듈화된 코드 설계**를 자연스럽게 유도합니다.

(물론 NestJS도 내부 로직은 런타임 리플렉션 기반이긴 합니다. 다만 스프링이 전역 단일 애플리케이션 컨테이너가 쭉 스캔을 해주고 처리해주는 방식이라면, NestJS는 모듈 단위로 해당 동작이 일어나죠.)

이러한 특성 때문에 NestJS는 **어느 정도 이상 규모가 되는 서비스**에서 아키텍처적 선택을 고민하게 됩니다.

이 글에서는 제가 3년간 NestJS 관련 다양한 아키텍처를 직접 짜보면서 NestJS의 **모듈 시스템 특성과 가장 궁합이 좋았던 계층형 모듈러 모놀리식 아키텍처**를 소개합니다.
실제 개발 과정에서 구조적 명확성과 확장성을 어떻게 확보했는지를 중심으로, 실용적인 설계 기준을 함께 정리해보려 합니다.

## 계층의 구분

계층형 아키텍처는 운영체제부터 대규모 백엔드 시스템에 이르기까지, 복잡도를 제어하고 변경 비용을 낮추는 구조적 해법으로 오랫동안 검증되어 왔습니다. 그러나 NestJS에 이 구조를 그대로 적용하기엔 몇 가지 실질적인 제약이 존재합니다.

Spring Framework처럼 전역 DI 컨테이너를 기반으로 동작하는 프레임워크에서는, 서로 다른 계층 간에도 **의존성 역전(DIP: Dependency Inversion Principle)**&#xC774; 자연스럽게 적용됩니다. **상위 계층에서 하위 계층을 주입받는 구조**뿐만 아니라, **인터페이스를 통해 하위 계층이 상위 계층에 의존**하도록 재구성하는 것 역시 어렵지 않습니다.

반면 NestJS는 명시적으로 모듈 단위로 DI 컨텍스트를 구성하기 때문에, **서로 다른 계층 간 의존성을 구성하려면 해당 provider들을 동일한 모듈 내에 등록해야만 동작**합니다. 즉, 의존성 역전을 위해선 오히려 여러 계층이 하나의 모듈에 응집되어야 하는 역설적 구조가 발생할 수 있습니다.

이러한 특성 때문에 NestJS에서는 "계층"이라는 개념 자체는 유지하되, **각 계층을 도메인 단위로 쪼개고, 모듈 내부에서 계층 간 책임 분리를 구현하는 방식**이 더 현실적인 접근이 됩니다. 즉, 모듈을 단위로 도메인 경계를 설정하고, 그 내부에 표현 → 구현 계층을 포함시키는 구조입니다.

결론적으로 NestJS에서 계층형 아키텍처를 적용하고자 할 때는, **엄격한 수직 분리보다는 도메인 중심의 모듈화를 기본 단위로 삼고, 계층은 모듈 내부의 조직 원칙으로 활용하는 설계 전략**이 바람직합니다.

그렇다고 해서 계층 분리를 완전히 배제한다는 의미는 아닙니다.
NestJS에서는 모듈을 도메인 단위로 나누되, **각 모듈 내부에 설계 계층(도메인 및 응용 로직)과 인프라스트럭처 계층을 함께 포함**하는 방식을 택합니다. 이로써 단일 모듈 내부에서 계층 간 책임을 응집력 있게 다루면서도, DI 제약을 피할 수 있습니다.

다만 시스템 전체로 보았을 때는 여전히 **모듈 간의 수직적인 계층적 참조 관계를 구성**합니다.
예를 들어, `payment`, `coupon`과 같은 도메인 모듈은 상위의 `payment-processing`, `promotion` 같은 응용 모듈에서 참조되고,
이 응용 모듈들은 다시 컨트롤러나 이벤트 컨슈머가 포함된 **BC(Bounded Context) 단위의 서비스 모듈**에서 불려집니다.

즉, **모듈 간의 계층적 의존 방향은 다음과 같은 상향식 참조 흐름**을 가집니다

![](https://d2r0pavv0lsiqc.cloudfront.net/projects/images/f76e8bfb-9d7c-4ac2-bc5e-19ec305dd1b7.webp)